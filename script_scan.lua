local repr = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Ozzypig/repr/master/repr.lua"))() -- formatter
local function tablr(table)
    return repr(table,{
        tabs=true,
        robloxFullName=true,
        robloxClassName=true,
        robloxProperFullName =true,
        pretty=true,
        sortKeys = true,
    })
end
local function JSONEncode(table)
	return game:GetService("HttpService"):JSONEncode(table)
end
local function ldscripts()
    local GC = {};
    local g  = getgc();
    GC["-path-"]={}
    for i, v in pairs(g) do
        if type(v) == "function" and is_synapse_function(v) ~= true  then
            local inf = getinfo(v)
            if GC[inf.short_src] == nil then
                GC[inf.short_src]= #GC["-path-"]+1
                GC["-path-"][ #GC["-path-"]+1 ] = inf.short_src
            end
            if inf.what == "C" then
                GC["-path-"][ GC[inf.short_src] ] = nil;
            end
        end
    end
    return GC["-path-"]
end

local function path(obj)
    local path_ = "";
    local p = obj.parent;
    if (p == nil) then
        return false
    end
    if (p.name == "Game") then
        return false
    end

    while (p.name~="Game") do
        path_=p.name .."."..  path_
        p = p.parent
        if p == nil then
            return false
        end
    end
    return string.sub(path_,1,-2)
end

local function is_table_equal(t1,t2,ignore_mt)
   local ty1 = type(t1)
   local ty2 = type(t2)
   if ty1 ~= ty2 then return false end
   if ty1 == "table" and ty2 == "table" then
        if #t1 == 0 and #t2 == 0 then
           return true
        elseif t1 == t2 then
            return true
        end
   end
   if ty1 == "function" and ty2 == "function" then
       if getinfo(t1).name == getinfo(t2).name then return true end
   end
   -- non-table types can be directly compared
   if ty1 ~= 'table' and ty2 ~= 'table' then return t1 == t2 end
   -- as well as tables which have the metamethod __eq
   local mt = getmetatable(t1)
   if not ignore_mt and mt and mt.__eq then return t1 == t2 end
   for k1,v1 in pairs(t1) do
      local v2 = t2[k1]
      if v2 == nil or not is_table_equal(v1,v2) then return false end
   end
   for k2,v2 in pairs(t2) do
      local v1 = t1[k2]
      if v1 == nil or not is_table_equal(v1,v2) then return false end
   end
   return true
end
local function dataf(func, tab)
    local inf = getinfo(func)
    if inf.what == "C" and is_synapse_function(func)==false then
        return true
    end
    
    if tab[inf.name] == nil then
        tab[inf.name] = {}
        tab[inf.name]["len"] = 0
        tab[inf.name]["upval"] = {}
        tab[inf.name]["const"] = {}
    end
    tab[inf.name]["len"]=tab[inf.name]["len"]+1
    
    local upval_ = getupvalues(func)
    if #tab[inf.name]["upval"] == 0 then
        tab[inf.name]["upval"][ #tab[inf.name]["upval"]+1 ]= {up = upval_, on=tab[inf.name]["len"]}
    elseif is_table_equal( tab[inf.name]["upval"][ #tab[inf.name]["upval"] ]["up"], upval_) then
        tab[inf.name]["upval"][ #tab[inf.name]["upval"]+1 ]= {up = upval_, on=tab[inf.name]["len"]}
    end

    local const_ = getconstants(func)
    if #tab[inf.name]["const"] == 0 then
        tab[inf.name]["const"][ #tab[inf.name]["const"]+1 ]= {cn = const_, on=tab[inf.name]["len"]}
    elseif is_table_equal( tab[inf.name]["const"][ #tab[inf.name]["const"] ]["cn"], const_) then
        tab[inf.name]["const"][ #tab[inf.name]["const"]+1 ]= {cn = const_, on=tab[inf.name]["len"]}
    end

    local protos = getprotos(func);
    if (#protos ~= 0) then
        tab[inf.name]["proto"] ={}
    end

    for _, v in pairs(protos) do
        dataf(v, tab[inf.name]["proto"])
    end

    return true;
end

rconsoleclear()
rconsoleprint("\n" .."Saving:")
local g= getgc()
--[[
local scripts = {};
local scripts_ = --ldscripts()
writefile("D_scripts.txt", repr(scripts_))
local filter = {}

if #filter ~= 0 then
	for i, v in pairs(scripts_) do
		local found = false;
	    path_ = v
	    for _, g in pairs(filter) do
	    	if path_==g then
	    		found = true;
	    	end
	    end
	    if found==false then
	   		scripts[#scripts+1]=path_
	    end
	end
else
    scripts = scripts_;
end

scripts_ = nil]]--
local scripts = {"Players.Megaldon66.PlayerScripts.Flux/client"}
local temps = {}
local on = 1;
local check = 1;
scripts[#scripts+1] = "";
while #scripts > on do
    local GC = {};
    local temp = {};
    while #temp ~= check and #scripts > on do 
        if scripts[on] ~= nil then
            temp[#temp+1] = scripts[on]
            rconsoleprint("\n\t" .. temp[#temp]);
        end
        on = on + 1
    end
    for i, v in pairs(g) do
        if type(v) == "function" then
            local src = getinfo(v).short_src
            for _, s in pairs(temp) do
                if string.find(src,s) then		-- can change this to src==s
                    if GC[src] == nil then
                        GC[src]={}
                        GC[src]["fenv"] = getfenv(v);
                    end
                    dataf(v, GC[src])
                end
            end
        end
        if (i % 500 == 0) then
            wait(.25)
        end
        if (i % 1000 == 0) then
            rconsoleprint("\nProgress: " .. i)
        end
    end
    writefile("D_save".. on ..".lua", tablr(GC))
    writefile("D_save".. on ..".json", HttpService:JSONEncode(GC))
    GC = nil
    for i, v in pairs(temp) do
	    temps[#temps+1]=v
    end
    temp = nil
    writefile("D_LOG_Save.txt", repr(temps))
end
temps = nil
--rconsoleclear()
rconsoleprint("\n" .."DONE\n")
rconsoleprint("\n" .. #scripts)
-- then look through that -- with fuzzy search or exact 
-- have filtering mechanics
-- add on changed event
-- add method for modification
-- add always locate method [uses data about function to find]

-- allow for orgnization by most function calling
-- to lowest calls

-- highest function ammount >> lowest function ammount
-- allow for script find