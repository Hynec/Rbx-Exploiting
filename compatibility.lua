--[[
    IDEALLY IN FUTURE
        getspecialinfo
        queue_on_teleport
        getnamecallmethod
        setnamecallmethod
    
    this is for non synapse executors mainly.
]]--

local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
_G.FILESYSTEM = {};
local HttpService = game:GetService("HttpService")
-- a compatability layer for exploits based on synapse api

-- Setup function for exploit.
local function get_exploit()
    local exploit = "ERROR" -- this shouldn't be possible..
    if pebc_load then-- is ProtoSmasher
        exploit = "ps"
    elseif elysianexecute then-- is Elysian
        exploit = "ely"
    elseif CALAMARI_PLATFORM then-- is Calamari
        exploit = "cl"
    elseif syn and syn.create_secure_function then-- is Synapse X
        expoit = "syn"
    elseif sirhurt_setup_secure_run then--Sirhurt
        exploit = "sh"
    elseif issentinelclosure then--Sentinel
        exploit = "se"
    else-- Unknown exploit.
        exploit = "unk"
    end
    return exploit;
end

local function maynot(txt)
    print("this exploit may not support: " .. txt)
    return false
end

workspace = game:GetService("Workspace");
local compatability = {
    getinstances = function()
        maynot("getinstances")
        print("using compatible function.")
        -- init with workspace descendants.
        local ALLDescendants = workspace:GetDescendants();
        table.insert(ALLDescendants, workspace);
        local game_t = {
            "Players",
            "Lighthing",
            "ReplicactedFirst",
            "StarterGui",
            "StarterPack"
        }
        for (_, tree in game_t) do
            for (_, des in game[tree]:GetDescendants()) do
                table.insert(ALLDescendants, des);
            end
            table.insert(ALLDescendants, game[tree])
        end
        return ALLDescendants;
    end,
    getscripts = function()
        maynot("getscripts")
        print("getscripts is very performance heavy.")
        local rest = {}
        local instances = getinstances()
        for _, inst in pairs(instances) do
            if inst.ClassName == "LocalScript" or inst.ClassName == "ModuleScript" then
                table.insert(rest, inst)
            end
        end
        return rest
    end,
    getloadedmodules = function()
        maynot("getloadedmodules")
        print("getloadedmodules is very performance heavy.")
        local rest = {}
        local instances = getinstances()
        for _, inst in pairs(instances) do
            if inst.ClassName == "ModuleScript" then
                table.insert(rest, inst)
            end
        end
        return rest
    end,
    setrawmetatable = function(obj, mt)
        local old_mt=getrawmetatable(obj)
        local state = isreadonly(old_mt)
        setreadonly(old_mt, false)
        for k, v in pairs(mt) do
            old_mt[k] = v
        end
        if state then
            setreadonly(old_mt, true);
        end
        return state;
    end,
    setproto = function(fn, idx, new_proto)
        if getprotos and hookfunction then
            hookfunction(getprotos(fn)[idx], new_proto);
        else
            maynot("setproto");
    end,
    getconstant = function(fn, idx)
        if getconstants then
            return getconstants(fn)[idx];
        else
            maynot("getconstant");
        end
    end,
    mousemoveabs = function(x, y)
        mousemoverel(x - mouse.X, y - mouse.Y)
    end,
    appendfile = function(path, new_txt)
        if writefile and readfile then
            return writefile(path, readfile(path) + new_txt)
        else
            return maynot("appendfile")
        end
    end,
    loadfile = function(path)
        if readfile and loadstring then
            return loadstring(readfile(path))
        else
            return maynot("loadfile")
        end
    end,
    isfile = function(path)
        local success, err = pcall(function()
            appendfile(path, "")
        end);
        return _G.FILESYSTEM[path] == "file" or success;
    end,
    isfolder = function(path)
        local success, err = pcall(function()
            makefolder(path)
        end);
        return _G.FILESYSTEM[path] == "folder" or success;
    end,
    listfiles = function(path)
        local files = {}
        for key,_ in pairs(_G.FILESYSTEM) do
            if key.len > path.len the
                local temp_path = key.sub(0, path.len)
                if temp_path == path and not key.sub(path.len, key.len).match("/") and isfile(key) then
                    table.insert(files, key)
                end
            end
        end
        return files;
    end,
    makefolder = function(path)
        if writefile then
            _G.FILESYSTEM[path] = "folder";
            writefile(path+"EXISTS1234.txt")
        else
            return maynot("loadfile")
        end
    end,
    -- we can't do anything about it lol..
    delfolder = function(path)
        _G.FILESYSTEM[path] = nil
    end,
    delfile = function(path)
        _G.FILESYSTEM[path] = nil;
    end,
    getclipboard = function()
        return _G.CLIPBOARD
    end,
    protect_gui = function(gui)
        protection[gui] = gui.Parent;
        gui.Parent = game.CoreGui;
    end,
    unprotect_gui = function(gui)
        gui.Parent = protection[gui]
        protection[gui] = nil;
    end,
    request = function(table)
        return HttpService:RequestAsync(table)
    end,
    secure_call = function(Function, Script, ...)
        if getfenv and getrenv and getsenv and set_thread_identity and get_thread_context then
            local old_env = getfenv();
            toProtect[Function] = Script:GetFullName() .. ':';
            local spoof_env = select(2, pcall(getsenv, Script));
            spoof_env = (type(spoof_env) == 'string' or not spoof_env) and getrenv() or spoof_env;
            spoof_env.script = spoof_env.script or Script;
            local setthreadcontext = setthreadcontext;
            set_thread_identity(2);
            local Level = 0;
            while true do
                if not pcall(setfenv, Level + 2, spoof_env) then
                    break;
                end;
                Level = Level + 1;
            end;
            local securityContext = get_thread_identity() or 6;
            local ret = table.pack( Function(...) ); 

            for i = 0, Level do
                setfenv(i, old_env);
            end;
        
            set_thread_identity(securityContext)
            return unpack(ret);
        else
            maynot("secure_call")
        end
    end
}



-- according to normal synapse conventions.
-- assume compatibility if there is no  compatibility middleware.

-- before saving to script env make sure that it doesn't exist.
local exploit_functions = {
    getreg = {
        ps = getregistry
    },
    getgc = {
        ps = get_gc_objects
    },
    getrenv = false,
    getgenv = false,
    getinstances = compatability.getinstances,
    getnilinstances = {
        ps = get_nil_instances
    },
    getscripts = {
        ps = function()
            -- good enough implementation..
            local rest = {}
            local scre = getscriptenvs()
            for k, _ in next, scre do
                rest[#rest + 1] = k
            end
            return rest
        end,
        se = getrunningscripts,
        others = compatability.getscripts
    },
    getloadedmodules = {
        ps = get_loaded_modules,
        --[ might have to use GC.
        others = compatability.getloadedmodules
    }
    getconnections = {
        ps = get_signal_connections,
    },
    -- possibly emulatable???
    firesignal = false,
    --[] may be simulatable
    fireclickdetector = {
        ps = click_detector
    },
    --[] may be simulatable
    firetouchinterest = false,
    gethiddenproperty = {
        ely = getnspval
    },
    sethiddenproperty = false,
    getsenv = false,
    getmenv = false,
    getcallingscript = {
        cl = getscriptcaller,--???
        ps = get_calling_script
    },
    getrawmetatable = {
        unk = function(...)
            maynot("getrawmetatable")
            return getmetatable(...)
        end
    },
    setrawmetatable = {
        cl = setmetatable,
        sh = setmetatable,
        others = compatability.setrawmetatable
    },
    setreadonly = {
       ps = function(t, state)
            if state then
                make_readonly(t)
            elseif not state then
                make_writeable(t)
            end
            return state;
       end
    },
    isreadonly = {
       ps = is_readonly
    },
    isrbxacctive= false,
    keypress = {
       ps = Input.KeyPress
    },
    keyrelease = {
        ps = Input.KeyUp
    },
    mouse1click = {
        ps = Input.LeftClick -- have diff states
    },
    mouse1press = false,
    mouse1release = false,
    mouse2click = {
        ps = Input.RightClick
    },
    mouse2press = false,
    mouse2release = false,
    mousescroll = {
        ps = Input.ScrollMouse
    },
    mousemoverel = {
        ps = Input.MoveMouse
    },
    mousemoveabs = {
        ps = compatibility.mousemoveabs
    },
    hookfunction = {
        ely= replaceclosure,
        ps = detour_function,-- also we need to return the current original_function.
    },
    newcclosure = {
        ps = protect_function
    },
    loadstring = false,
    checkcaller = {
        ps=is_protosmasher_caller
    },
    islclosure = {
        ps = is_l_closure,
    },
    dumpstring = {
        cl = serialize,
        ps = get_script_bytecode
    },
    decompile = false,
    readfile = false,
    writefile = false,
    appendfile = compatability.appendfile,
    loadfile = compatability.loadfile,
    listfiles = compatability.listfiles,
    isfile = compatability.isfile,
    isfolder = compatability.isfolder,
    makefolder = {
        cl = mkdir,
        se = createdirectory,
        others = compatability.makefolder,
    },
    delfolder = compatability.delfolder,
    delfile = compatability.delfile,
    setclipboard  = {
        ely = Clipboard.set
    },
    getclipboard = compatability.getclipboard,
    setfflag = false,
    getnamecallmethod = false,
    setnamecallmethod = false,
    getspecialinfo = false,--compatability.getspecialinfo,
    saveinstance = {
        ps = function() end, -- this can be added.
    },
    getconstants = {
        ely = getconsts
    },
    getconstant = compatability.getconstant,
    setconstant = {
        ely = setconst
    },
    getupvalues = false,
    getupvalue = false,
    setupvalue = false,
    getprotos = {
        sh = function(fn)
            local protos = {};
            local i = 0;
            while success == true do
                i = i+1;
                local success, err = pcall(function()
                    table.insert(protos, getproto(fn, i)
                end)
            end
            return protos
        end,
        ps = function() end -- might be addable
    },
    getproto = {
        ps = function() end -- might be addable
    },
    setproto = compatability.setproto,
    ---------------------------------------------
    ----STACK MIGHT BE ADDED---------------------
    getstack = {
        sh = function() end, -- this can be added by getinfo and getupvalues?
        ps = function() end -- might be addable.
    },
    setstack = {
        sh = function() end, -- this can be added by getinfo and getupvalues?
        ps = function() end -- might be addable.
    },
    ---------------------------------------------
    ---------------------------------------------
    getinfo =false,
    syn = {
        cache_replace = false,
        cache_invalidate = false,
        is_cached = false,
        get_thread_identity = {
            cl = getcontext,
            ps = get_thread_context,
            se = getthreadcontext,
        },
        set_thread_identity = {
            cl = setcontext,
            se = setthreadcontext
        },
        queue_on_teleport = false,--compatability.queue_on_teleport,
        protect_gui = {
            sh = function(gui)
                gui_protection[gui] = gui.Parent;
                gui.Parent=get_hidden_gui();
            end,
            ps = function(gui)
                gui_protection[gui]=gui.Parent;
                gui.Parent=get_hidden_gui();
            end,
            ely = function(gui)
                gui_protection[gui]=gui.Parent;
                gui.Parent=gethui();
            end,
            others = compatability.protect_gui
        },
        unprotect_gui = {
            sh = function(gui)
                gui.Parent=protection[gui]; -- not exactly sure how these work...
                protection[gui] = nil;
            end,
            ps = function(gui)
                gui.Parent=protection[gui];
                protection[gui] = nil;
            end,
            ely = function(gui)
                gui.Parent=protection[gui];
                protection[gui] = nil;
            end,
            others = compatability.unprotect_gui
        },
        is_beta = false,
        request = {
            sh = http_request,
            others = compatability.request
        },
        secure_call = compatability.secure_call
    }
}
exploit_functions.getregistry = exploit_functions.getreg;
exploit_functions.setmetatable = exploit_functions.setrawmetatable;
-- unload the variables into the executor scope smartly.

local exploit = get_exploit();

local function unpacket(table, scope)
    local err = function(...)
        maynot(key);
        return nil;
    end
    for key, val in pairs(table) do
        if key ~= "syn" and not scope[key] then
            if key == "listfiles" then
                listfiles_orig = false;
            elseif key == "getclipboard" then
                getclipboard_orig = false
            elseif key == "secure_call" then
                secure_call_orig = false
            end
            if type(val) == "table" then
                scope[key] = val[exploit] or val["others"] or err;
            elseif type(val) == "function" then
                scope[key] = val
            elseif val == false then
                scope[key]= err
            end
        end
    end
end

if getrenv then
    unpacket(exploit_functions, getrenv());
    getrenv()["syn"] = {}
    unpacket(exploit_functions["syn"],getrenv()["syn"])
else
    print("THE SCOPE MUST BE EDDITED AS GETRENV DOES NOT EXIST")
end

if not listfiles_orig then
    -- intecept the writefile to add to the stuff..
    _G.path_folder= function(path)
        local folders = string.split(path, "/")
        local past = "";
        for i = 1, #folders-1 do
            past = past + folders[i] + "/";
            _G.FILESYSTEM[past] = "folder";
        end
    end

    old_write = hookfunction(writefile, function(path, txt)
        if path ~= "EXISTS1234.txt" then
            _G.FILESYSTEM[path] = "file"; -- something was written here.
            _G.path_folder(path);
            old_write(path, txt)
        end
    end)
    old_append = hookfunction(appendfile, function(path, txt)
        if path ~= "EXISTS1234.txt" then
            _G.FILESYSTEM[path] = "file"; -- something was written here.
            _G.path_folder(path);
            old_append(path, txt)
        end
    end)
end

if not getclipboard_orig then
    old_clip = hookfunction(setclipboard, function(txt)
        _G.CLIPBOARD = txt;
        old_clip(txt)
    end);
end

if not secure_call_orig then
    local toProtect = {};
    local oldTraceback;

    -- retarded code but w/e
    local function isProtectedCaller(Function)
    	for i = 0, 30 do
    		local stackInfo = debug.getinfo(i);
    		if stackInfo then
    			if Function == stackInfo.func then
    				return true;
    			end;
    		else
    			break;
    		end;
    	end;
    	return false;
    end;

    oldTraceback = hookfunction(debug.traceback, function()
    	local stackTrace = oldTraceback();
    	for Function, spoofedTrace in next, toProtect do
    		if isProtectedCaller(Function) then

    			-- enumerate through all lines and store in table, for easier replacing.
    			local Lines = {};
    			stackTrace:gsub('[^\n\r]+', function(Line)
    				--replace exploit trace with spoofed trace
    				Lines[#Lines + 1] = Line:gsub('^@:', spoofedTrace);
    			end);

    			-- Remove exploit traceback lines.
    			table.remove(Lines, 1);
    			table.remove(Lines, #Lines - 1);
            
    			return table.concat(Lines, '\n') .. '\n';
    		end;
    	end;

    	-- pattern match to remove first line, which would be this hookfunction hook.
    	return stackTrace:match'[^\n\r]*\n?(.*)';
    end);
end


return function(lscope)
    if lscope == nil then
        lscope = getrenv();
    end
    if lscope then
        unpacket(exploit_functions, lscope);
        lscope["syn"] = {}
        unpacket(exploit_functions["syn"],lscope["syn"])
    else
        error("THE SCOPE MUST BE EDDITED AS GETRENV DOES NOT EXIST")
    end
end