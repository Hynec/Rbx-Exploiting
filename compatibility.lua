-- "Completely updated to work"
local player = game:GetService("Players").LocalPlayer
local mouse = player:GetMouse()
_G.FILESYSTEM = {};
local protection = {};
_G.hookfunctions_replace = {}; -- no way to fix 
_G.hookfunctions_return = {};
local HttpService = game:GetService("HttpService");
-- a compatability layer for exploits based on synapse api

-- Setup function for exploit.
local function get_exploit()
    local exploit = "ERROR" -- this shouldn't be possible..
    if pebc_load then-- is ProtoSmasher
        exploit = "ps"
    elseif elysianexecute then-- is Elysian
        exploit = "ely"
    elseif CALAMARI_PLATFORM then-- is Calamari
        exploit = "cl"
    elseif syn and syn.create_secure_function then-- is Synapse X
        expoit = "syn"
    elseif sirhurt_setup_secure_run then--Sirhurt
        exploit = "sh"
    elseif issentinelclosure then--Sentinel
        exploit = "se"
    else-- Unknown exploit.
        exploit = "unk"
    end
    return exploit;
end
local exploit = get_exploit();


local function expname(suffix)
    if suffix then-- is ProtoSmasher
        name = "ProtoSmasher"
    elseif suffix=="ely" then-- is Elysian
        name = "Elysian"
    elseif suffix=="cl" then-- is Calamari
        name = "Calimari"
    elseif suffix=="syn" then-- is Synapse X
        name = "Synapse X"
    elseif suffix=="sh" then--Sirhurt
        name = "SirHurt"
    elseif suffix=="se" then--Sentinel
        name = "Sentinel"
    else-- Unknown exploit.
        name = "Unknown"
    end
    return name;
end
local function maynot(ex, txt)
    print(expname(ex) .. " doesn't support: " .. txt)
    return false
end
local workspace = workspace;
if not workspace then
    workspace = game:GetService("Workspace");
end
local compatability = {
    getinstances = function()
        maynot(exploit, "getinstances")
        print("using compatible function.")
        -- init with workspace descendants.
        local ALLDescendants = workspace:GetDescendants();
        table.insert(ALLDescendants, workspace);
        local game_t = {-- change these to places you'd like to check.
            "Players",
            "ReplicatedStorage",
            "StarterGui",
            "StarterPack"
        }
        for _, tree in pairs(game_t) do
            for d, inst in pairs(game[tree]:GetDescendants()) do
                table.insert(ALLDescendants, inst);
            end
            table.insert(ALLDescendants, game[tree])
        end
        return ALLDescendants;
    end,
    getscripts = function()
        maynot(exploit, "getscripts")
        print("getscripts is very performance heavy.")
        local rest = {}
        local instances = getinstances()
        for _, inst in pairs(instances) do
            if inst.ClassName == "LocalScript" or inst.ClassName == "ModuleScript" then
                table.insert(rest, inst)
            end
        end
        return rest
    end,
    getloadedmodules = function()
        maynot(exploit, "getloadedmodules")
        print("getloadedmodules is very performance heavy.")
        local modules = {}
        local found = {};
        for _, func in pairs(getgc()) do
            if type(func) == "function" then
                local t_src = getinfo(func).short_src;
                if not found[t_src] then
                    found[t_src] = true
                    local fenv = getfenv(func).script;
                    if fenv.ClassName == "ModuleScript" then
                        table.insert(modules, fenv);
                    end
                end
            end
        end
        return modules;
    end,
    setrawmetatable = function(obj, mt)
        local old_mt=getrawmetatable(obj)
        local state = isreadonly(old_mt)
        setreadonly(old_mt, false)
        for k, v in pairs(mt) do
            old_mt[k] = v
        end
        if state then
            setreadonly(old_mt, true);
        end
        return state;
    end,
    getprotos = function(fn)
        if getproto then
            local protos = {};
            local i = 0;
            while success == true do
                i = i+1;
                local success, er = pcall(function()
                    table.insert(protos, getproto(fn, i))
                end)
            end
            return protos
        else
            return maynot(exploit, "getprotos")
        end
    end,
    setproto = function(fn, idx, new_proto)
        if getprotos and hookfunction then
            hookfunction(getprotos(fn)[idx], new_proto);
        else
            maynot(exploit, "setproto");
        end
    end,
    getconstant = function(fn, idx)
        if getconstants then
            return getconstants(fn)[idx];
        else
            maynot(exploit, "getconstant");
        end
    end,
    mousemoveabs = function(x, y)
        mousemoverel(x - mouse.X, y - mouse.Y)
    end,
    appendfile = function(path, new_txt)
        if writefile and readfile then
            return writefile(path, readfile(path) + new_txt)
        else
            return maynot(exploit, "appendfile")
        end
    end,
    loadfile = function(path)
        if readfile and loadstring then
            return loadstring(readfile(path))
        else
            return maynot(exploit, "loadfile")
        end
    end,
    isfile = function(path)
        local success, er = pcall(function()
            appendfile(path, "")
        end);
        return _G.FILESYSTEM[path] == "file" or success;
    end,
    isfolder = function(path)
        local success, er = pcall(function()
            makefolder(path)
        end);
        return _G.FILESYSTEM[path] == "folder" or success;
    end,
    listfiles = function(path)
        local files = {}
        for key,_ in pairs(_G.FILESYSTEM) do
            if key.len > path.len then
                local temp_path = key.sub(0, path.len)
                if temp_path == path and not key.sub(path.len, key.len).match("/") and isfile(key) then
                    table.insert(files, key)
                end
            end
        end
        return files;
    end,
    makefolder = function(path)
        if writefile then
            _G.FILESYSTEM[path] = "folder";
            writefile(path+"EXISTS1234.txt")
        else
            return maynot(exploit, "loadfile")
        end
    end,
    -- we can't do anything about it lol..
    delfolder = function(path)
        _G.FILESYSTEM[path] = nil
    end,
    delfile = function(path)
        _G.FILESYSTEM[path] = nil;
    end,
    getclipboard = function()
        return _G.CLIPBOARD
    end,
    protect_gui = function(gui)
        protection[gui] = gui.Parent;
        gui.Parent = game.CoreGui;
    end,
    unprotect_gui = function(gui)
        gui.Parent = protection[gui]
        protection[gui] = nil;
    end,
    request = function(table)
        return HttpService:RequestAsync(table)
    end,
    secure_call = function(Function, Script, ...)
        if getfenv and getrenv and getsenv and set_thread_identity and get_thread_context then
            local old_env = getfenv();
            toProtect[Function] = Script:GetFullName() .. ':';
            local spoof_env = select(2, pcall(getsenv, Script));
            spoof_env = (type(spoof_env) == 'string' or not spoof_env) and getrenv() or spoof_env;
            spoof_env.script = spoof_env.script or Script;
            local setthreadcontext = setthreadcontext;
            set_thread_identity(2);
            local Level = 0;
            while true do
                if not pcall(setfenv, Level + 2, spoof_env) then
                    break;
                end;
                Level = Level + 1;
            end;
            local securityContext = get_thread_identity() or 6;
            local ret = table.pack( Function(...) ); 

            for i = 0, Level do
                setfenv(i, old_env);
            end;
        
            set_thread_identity(securityContext)
            return unpack(ret);
        else
            maynot(exploit, "secure_call")
        end
    end
}



-- according to normal synapse conventions.
-- assume compatibility if there is no  compatibility middleware.

-- before saving to script env make sure that it doesn't exist.
local Input = Input;
if not Input then
    Input = {}
end
local Clipboard = Clipboard;
if not Clipboard then
    Clipboard = {}
end
local debug = debug
if not debug then
    debug = {}
end
local exploit_functions = {
    getreg = {
        ps = debug.getregistry
    },
    getgc = {
        ps = get_gc_objects
    },
    getrenv = false,
    getgenv = false,
    getinstances = compatability.getinstances,
    getnilinstances = {
        ps = get_nil_instances
    },
    getscripts = {
        ps = function()
            -- good enough implementation..
            local rest = {}
            local scre = getscriptenvs()
            for k, _ in next, scre do
                rest[#rest + 1] = k
            end
            return rest
        end,
        se = getrunningscripts,
        others = compatability.getscripts
    },
    getloadedmodules = {
        ps = get_loaded_modules,
        others = compatability.getloadedmodules--// might have to use GC.
    },
    getconnections = {
        ps = get_signal_connections,
    },
    --// possibly emulatable???
    firesignal = false,
    --// may be simulatable
    fireclickdetector = {
        ps = click_detector
    },
    --// may be simulatable
    firetouchinterest = false,
    gethiddenproperty = {
        ely = getnspval
    },
    sethiddenproperty = false,
    getsenv = false,
    getmenv = false,
    getcallingscript = {
        cl = getscriptcaller,
        ps = get_calling_script
    },
    getrawmetatable = {
        unk = function(...)
            maynot("getrawmetatable will use getmetatable.")
            return getmetatable(...)
        end
    },
    setrawmetatable = {
        cl = setmetatable,
        sh = setmetatable,
        others = compatability.setrawmetatable
    },
    setreadonly = {
       ps = function(t, state)
            if state then
                make_readonly(t)
            elseif not state then
                make_writeable(t)
            end
            return state;
       end
    },
    isreadonly = {
       ps = is_readonly
    },
    isrbxacctive= false,
    keypress = {
       ps = Input.KeyPress
    },
    keyrelease = {
        -- these may cause errors...
        ps = Input.KeyUp
    },
    mouse1click = {
        ps = Input.LeftClick --//have diff states
    },
    mouse1press = false,
    mouse1release = false,
    mouse2click = {
        ps = Input.RightClick
    },
    mouse2press = false,
    mouse2release = false,
    mousescroll = {
        ps = Input.ScrollMouse
    },
    mousemoverel = {
        ps = Input.MoveMouse
    },
    mousemoveabs = {
        ps = compatability.mousemoveabs
    },
    checkcaller = {
        ps=is_protosmasher_caller
    },
    hookfunction = {
        ely= replaceclosure
        --[[ps = function(func, replace)            apperently not needed...
            detour_function(func, function(...)
                local args = {...}
                if args[1] == "fix it now please." and checkcaller() then
                    return original_function;
                else
                    return replace(...)
                end
            end)
            return func("fix it now please.");
        end,]]--
    },
    newcclosure = {
        ps = protect_function
    },
    loadstring = false,
    islclosure = {
        ps = is_l_closure,
        others = compatability.islclosure
    },
    dumpstring = {
        cl = serialize,
        ps = get_script_bytecode
    },
    decompile = false,
    readfile = false,
    writefile = false,
    appendfile = compatability.appendfile,
    loadfile = compatability.loadfile,
    listfiles = compatability.listfiles,
    isfile = compatability.isfile,
    isfolder = compatability.isfolder,
    makefolder = {
        cl = mkdir,
        se = createdirectory,
        others = compatability.makefolder,
    },
    delfolder = compatability.delfolder,
    delfile = compatability.delfile,
    setclipboard  = {
        others = writeclipboard,
        ely = Clipboard.set
    },
    getclipboard = compatability.getclipboard,
    setfflag = false,
    getnamecallmethod = false,
    setnamecallmethod = false,
    getspecialinfo = false,--//compatability.getspecialinfo,
    saveinstance = {
        ps = false, -- //this can be added.
    },
    is_synapse_function = {
        ps = is_protosmasher_closure,
        se = issentinelclosure,
        sh = is_sirhurt_closure,
        others = checkclosure
    },
    debug = {
        getconstants = {
            ely = getconsts
        },
        getconstant = compatability.getconstant,
        setconstant = {
            ely = setconst
        },
        getupvalues = false,
        getupvalue = false,
        setupvalue = false,
        getprotos = compatability.getprotos,
        traceback = false,
        getproto = false,
        setproto = compatability.setproto,
        ---------------------------------------------
        ----STACK MIGHT BE ADDEDABLE-----------------
        getstack = false,   --for ps and sh
        setstack = false,
        ---------------------------------------------
        ---------------------------------------------
        getinfo = false
    },
    syn = {
        cache_replace = false,
        cache_invalidate = false,
        is_cached = false,
        get_thread_identity = {
            cl = getcontext,
            ps = get_thread_context,
            se = getthreadcontext,
        },
        set_thread_identity = {
            cl = setcontext,
            se = setthreadcontext
        },
        queue_on_teleport = false,--//compatability.queue_on_teleport,
        protect_gui = {
            sh = function(gui)
                gui_protection[gui] = gui.Parent;
                gui.Parent=get_hidden_gui();
            end,
            ps = function(gui)
                gui_protection[gui]=gui.Parent;
                gui.Parent=get_hidden_gui();
            end,
            ely = function(gui)
                gui_protection[gui]=gui.Parent;
                gui.Parent=gethui();
            end,
            others = compatability.protect_gui
        },
        unprotect_gui = {
            sh = function(gui)
                gui.Parent=protection[gui]; --not exactly sure how these work...
                protection[gui] = nil;
            end,
            ps = function(gui)
                gui.Parent=protection[gui];
                protection[gui] = nil;
            end,
            ely = function(gui)
                gui.Parent=protection[gui];
                protection[gui] = nil;
            end,
            others = compatability.unprotect_gui
        },
        is_beta = false,
        request = {
            sh = http_request,
            others = compatability.request
        },
        secure_call = false
    }
}
-- unload the variables into the executor scope smartly.

local exploit = get_exploit();
local listfiles_orig = true;
local getclipboard_orig = true;
local secure_call_orig= true;

local err = function(key)
    return function(...)
        maynot(exploit, key);
        return false;
    end;
end

local function unpacket(table, scope)
    for key, val in pairs(table) do
        if key ~= "syn" and key ~= "debug" and not scope[key] then
            if key == "listfiles" then
                listfiles_orig = false;
            elseif key == "getclipboard" then
                getclipboard_orig = false
            elseif key == "secure_call" then
                secure_call_orig = false
            end
            if type(val) == "table" then
                scope[key] = val[exploit] or val["others"] or err(key);
            elseif type(val) == "function" then
                local success, err = pcall(function()
                    scope[key] = val
                end)
                if success == false then
                    print("WTF it says " .. key .. " doesn't exist but doesn't let me write to it..")
                end
            elseif val == false then
                scope[key]= err(key);
            end
        end
    end
end

local function attempt(lscope, patch)
    local function patchet(patch,exscope)
        if type(patch) == "table" and #patch ~= 0 then
            for key, val in pairs(patch) do
                if key ~= "syn" or key ~= "debug" then
                    exscope[key] = val
                else
                    patchet(patch[key], exscope[key]);
                end
            end
        end
    end
    if patch then
        patchet(patch, exploit_functions)
    end
    if lscope == nil then
        lscope = getrenv();
    end
    if lscope then
        if not lscope["syn"] then
            lscope["syn"] = {}
            exploit_functions.syn.setmetatable = exploit_functions.setrawmetatable;
            unpacket(exploit_functions["syn"],lscope["syn"])
            for i, v in pairs(syn) do
                exploit_functions[i] = v
            end
        end
        if not lscope["debug"] then
            lscope["debug"] = {}
        end
        unpacket(exploit_functions["debug"],lscope["debug"])
        for i, v in pairs(debug) do
            exploit_functions[i] = v
        end
        exploit_functions.getregistry = exploit_functions.getreg;
        if patch then
            patchet(patch, exploit_functions)
        end
        unpacket(exploit_functions, lscope);
        if not listfiles_orig and writefile("testing12345.txt", "12345") and appendfile then
            -- intecept the writefile to add to the stuff..
            local sucess, er= pcall(function()
                _G.path_folder= function(path)
                    local folders = string.split(path, "/")
                    local past = "";
                    for i = 1, #folders-1 do
                        past = past + folders[i] + "/";
                        _G.FILESYSTEM[past] = "folder";
                    end
                end
                
                old_write = hookfunction(writefile, function(path, txt)
                    if path ~= "EXISTS1234.txt" then
                        _G.FILESYSTEM[path] = "file"; -- something was written here.
                        _G.path_folder(path);
                        old_write(path, txt)
                    end
                end)
                old_append = hookfunction(appendfile, function(path, txt)
                    if path ~= "EXISTS1234.txt" then
                        _G.FILESYSTEM[path] = "file"; -- something was written here.
                        _G.path_folder(path);
                        old_append(path, txt)
                    end
                end)
            end)
            if not success then
                listfiles = err("listfiles");
            end
        end

        if not getclipboard_orig and getclipboard("") then
            local sucess, er= pcall(function()
                old_clip = hookfunction(setclipboard, function(txt)
                    _G.CLIPBOARD = txt;
                    old_clip(txt)
                end);
            end)
            if not success then
                getclipboard = err("getclipboard");
            end
        end

        if not secure_call_orig and traceback and getinfo(1) then
            local sucess, er= pcall(function()
                local toProtect = {};
                local oldTraceback;
                
                -- retarded code but w/e
                local function isProtectedCaller(Function)
                	for i = 0, 30 do
                		local stackInfo = debug.getinfo(i);
                		if stackInfo then
                			if Function == stackInfo.func then
                				return true;
                			end;
                		else
                			break;
                		end;
                	end;
                	return false;
                end;

                oldTraceback = hookfunction(debug.traceback, function()
                	local stackTrace = oldTraceback();
                	for Function, spoofedTrace in next, toProtect do
                		if isProtectedCaller(Function) then
                        
                			-- enumerate through all lines and store in table, for easier replacing.
                			local Lines = {};
                			stackTrace:gsub('[^\n\r]+', function(Line)
                				--replace exploit trace with spoofed trace
                				Lines[#Lines + 1] = Line:gsub('^@:', spoofedTrace);
                			end);
                        
                			-- Remove exploit traceback lines.
                			table.remove(Lines, 1);
                			table.remove(Lines, #Lines - 1);
                        
                			return table.concat(Lines, '\n') .. '\n';
                		end;
                	end;
                
                	-- pattern match to remove first line, which would be this hookfunction hook.
                	return stackTrace:match'[^\n\r]*\n?(.*)';
                end);
                if not secure_call then
                    secure_call = compatability.secure_call
                    debug.secure_call=secure_call
                end
            end)
            if not success then
                secure_call = err("secure_call");
                debug.secure_call=secure_call
            end
        end
    else
        error("THE SCOPE MUST BE EDDITED AS GETRENV DOES NOT EXIST")
    end
end
return attempt
