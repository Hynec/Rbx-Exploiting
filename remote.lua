local repr = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Ozzypig/repr/master/repr.lua"))() -- formatter
local function tablr(table)
    return repr(table,{
        tabs=true,
        robloxFullName=true,
        robloxClassName=true,
        robloxProperFullName =true,
        pretty=true,
        sortKeys = true,
    })
end
--==============================================
local getinfo = getinfo
local hookfunction = hookfunction
local typeof = typeof
local Instance = Instance.new
local game = game
local getrawmetatable = getrawmetatable
local setreadonly = setreadonly
local getnamecallmethod = getnamecallmethod
local newcclosure = newcclosure;
local checkcaller = checkcaller;
--==============================================
--==============================================
local remote_hooks = {};
local Methods = {
	RemoteEvent = "FireServer",
    RemoteFunction = "InvokeServer",
    BindableEvent = "Fire",
    BindableFunction = "Invoke"
}

local IsValidCall=function(Remote, Method)
    if Methods[Remote.ClassName] ~= nil then
	    return true
    else
        return false
    end
end


do
    --function hooking FireServer(Remote, ...)
    for Class, Method in pairs(Methods) do
        local orig_func = Instance(Class)[Method]
        orig_func_ = hookfunction(orig_func, function(selff, ...)
            if not checkcaller() then
                local caller = getinfo(3);
    		    if typeof(selff) == "Instance" and IsValidCall(selff, Method) then
                    for i, rfunc in next, remote_hooks do 
                        local trying = rfunc(selff, Method, caller, ...)
                        if trying then
                            return trying;
                        end
                    end
    		    end
                return orig_func_(selff, ...)
            end
        end)
    end
end

do
-- Namecall hooking Remote:FireServer(...)
local MT = getrawmetatable(game)
local __nc = MT.__namecall
setreadonly(MT, false)
MT.__namecall=newcclosure(function(selff, ...)
    local Method = getnamecallmethod()
    if not checkcaller() and IsValidCall(selff, Method) then
        local caller = getinfo(3);
        for _, rfunc in pairs(remote_hooks) do 
            local trying = rfunc(selff, Method, caller, ...)
            if trying then
                return trying;
            end
        end
	end
    return __nc(selff, ...)
end)
setreadonly(MT, true)
end

local function Hook_Remote(func, settings)
    local T_Event = settings.event;
    local T_Method = settings.method;
    local T_Function = settings.func;
    local function intable(table,value)
        for i, v in next, table do
            if v == value then
                return true
            end
        end
        return false;
    end
    remote_hooks[#remote_hooks+1] = function(event, nc_method, caller, ...)    --- need to learn how these opperate
        if  (not T_Event or intable(T_Event,event)) and 
            (not T_Method or intable(T_Method, nc_method)) and 
            (not T_Function or intable(T_Function,caller.func)) then
            -- done filtering lol.
            return func(event, nc_method, caller, ...)
        end
    end
    return #remote_hooks
end
local function restore(id)
    remote_hooks[id] = nil;
end
remote_hooks = {};
Hook_Remote(function(event, method, caller, ...)
    print("Event: " .. tablr(event))
    print("Method: " .. tablr(method))
    print("Caller: " .. tablr(caller))
    print("Arguments: " .. tablr({...}))
end,{
    method = {"FireServer","InvokeServer"}
})