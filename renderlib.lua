local game = game;
local HT = game:GetService("HttpService")
local PlrCamera = workspace.CurrentCamera;
local UserInputService	= game:GetService("UserInputService");
local Heartbeat = game:GetService('RunService').Heartbeat;
local instance	= Instance.new;
local v3,cf,udim2	= Vector3.new,CFrame.new,UDim2.new;
local IsA = game.IsA;
local GetChildren = game.GetChildren;
local GetPropertyChangedSignal = game.GetPropertyChangedSignal;
local Player			= game.Players.LocalPlayer;
local GUI		= instance("ScreenGui");
local RenderFrame = instance("Frame");
local ViewPort = instance("ViewportFrame");
local wait = wait;
local tick = tick;
GUI.Parent = game.CoreGui;
RenderFrame.Parent = GUI;
ViewPort.Parent = RenderFrame;
GUI.Enabled = true;
GUI.IgnoreGuiInset=true;
RenderFrame.Size = UDim2.new(1, 0, 1, 0);
RenderFrame.BackgroundTransparency = 1;
RenderFrame.Visible = true;
ViewPort.BackgroundTransparency = 1;
ViewPort.Size = UDim2.new(1, 0, 1, 0);
ViewPort.Visible = true;
--Create the viewport camera
local Camera		= instance("Camera");
Camera.CFrame		= PlrCamera.CFrame;
ViewPort.CurrentCamera= Camera;

GetPropertyChangedSignal(PlrCamera, "CFrame"):Connect(function()
	Camera.CFrame = PlrCamera.CFrame;
end)
GetPropertyChangedSignal(PlrCamera, "FieldOfView"):Connect(function()
	Camera.FieldOfView = PlrCamera.FieldOfView;
end)

local Threads   = {};
local function Destructor(table, name)
    -- should destroy the current scope of table and all desc
    if table == nil then
        return nil;
    end
    --print("Name:\t"..name)
    --print("Destruct:\t" .. repr(table));
    local handle = table["__Handler__"]
    for i, v in pairs(table) do
        if i ~= "__Handler__" then
            Destructor(v);
        end
    end
    for i, v in pairs(handle) do
        if i ~= "f_obj" then
            local success, err = pcall(function()
                v:Disconnect()
            end)
        else
            v:Destroy()
        end
    end
    table = {};
    return true;
end


local function RenderPart(Part, R_Parent, tab)
    if IsA(Part, "MeshPart") or IsA(Part, "Part") then
        local _name_ = Part.Name .. "_" .. math.random(1,10000)
        tab[_name_] = {}
        tab[_name_]["__Handler__"] = {}
        local n_Thread = tab[_name_]["__Handler__"];

        -- create Part and make editable.
        local a= Part.Archivable;
        Part.Archivable= true;
        local RenderClone= Part:Clone();
        Part.Archivable= a;
        RenderClone.Parent = R_Parent;
        n_Thread["obj"] = Part
        n_Thread["f_obj"] = RenderClone
        -------------------------------------------------------------------------
        -- HANDLE CFRAME UPATES -------------------------------------------------
        local function CFrame_Update()
            local max = 5;
            local current = 0;
            local prev = tick()*1000;
            n_Thread["CFrame"] = GetPropertyChangedSignal(Part, "CFrame"):Connect(function()
                if (tick()*1000) - prev <= 1/60 then    -- if part is being updated more than 60 fps then switch to heartbeat
                    current = current + 1;
                else
                    current = 0
                end
                if max > 5 then
                    n_Thread["CFrame"]:Disconnect();
                    Heartbeat_Update()
                end
                RenderClone.CFrame = Part.CFrame;
            end)
            return n_Thread["CFrame"];
        end
        local function Heartbeat_Update()
            local max = 5;
            local current = 0;
            local prev = tick();
            n_Thread["CFrame"] = Heartbeat:Connect(function()
                if tick() - prev >= 20 then    -- if part is being updated more than 20 seconds
                    current = current + 1;
                else
                    current = 0
                end
                if max > 5 then
                    n_Thread["CFrame"]:Disconnect();
                    CFrame_Update();
                end
                RenderClone.CFrame = Part.CFrame;
            end)
            return n_Thread["CFrame"];
        end
        Heartbeat_Update()
        -------------------------------------------------------------------------
        -------------------------------------------------------------------------

        -- Handle addition
        n_Thread["Added"]=Part.ChildAdded:Connect(function(Child)
            wait() --Let it load in
            RenderObj(Child, Part, tab[_name_]);
        end)

        -- Handle Destruction       [not working properly]
        n_Thread["Removed"]=Part.ChildRemoved:Connect(function(Child)
            -- find the part.
            for i, v in pairs(tab[_name_]) do
                pcall(function()
                    if v["__Handler__"]["obj"] == Child then
                        Destructor(v, Child.Name);
                    end
                    print("eee")
                end)
            end
        end)

        -- Changed Property
        n_Thread["Changed"]=Part.Changed:Connect(function(property)
            RenderClone[property] = Part[property];
        end)

        return tab[_name_];
    else
        return false;
    end
end

local function ObjHandler(obj, f_obj, table)
    --print(repr(obj))
    local _name_ = obj.Name .. "_" .. math.random(1,10000)
    table[_name_] = {}
    table[_name_]["__Handler__"] = {}
    local n_Thread = table[_name_]["__Handler__"];
    n_Thread["obj"] = obj;
    n_Thread["f_obj"] = f_obj;
    -- Handle addition
    n_Thread["Added"] = obj.ChildAdded:Connect(function(Child)
        wait()
        RenderObj(Child, f_obj, table[_name_]);
    end)
    -- Handle Destruction       [not working properly]
    n_Thread["Removed"] = obj.ChildRemoved:Connect(function(Child)
        -- find the part.
        for i, v in pairs(table[_name_]) do
            pcall(function()
                if v["__Handler__"]["obj"] == Child then
                    Destructor(v, Child.Name);
                end
                print("done?")
            end)
        end
    end)
    return table[_name_]
end

function RenderObj(obj, Parent, table)
    if IsA(obj, "Model") or IsA(obj, "Folder") or obj.ClassName == "Tool" then
        --Basically for ESP
        local ModelClone = instance("Model");
        ModelClone.Name	 = obj.Name do
            local ttable = ObjHandler(obj, ModelClone, table);
            local ModelParts = GetChildren(obj);
            local human = obj:FindFirstChildOfClass("Humanoid", true)
            for i=1, #ModelParts do
                local rpart = ModelParts[i]
                if not IsA(rpart, "Script") then
                    if IsA(rpart, "MeshPart") or IsA(rpart, "Part") then
                        RenderPart(rpart, ModelClone, ttable);
                    elseif human then
                        RenderObj(rpart, ModelClone, ttable);
                    end
                end
            end
            ModelClone.Parent = Parent;
        end
    elseif IsA(obj, "Part") then
        -- if it's a part send it to the renderpart
        RenderPart(obj, Parent, table);
    elseif IsA(obj, "Accoutrement") then
        RenderPart(obj.Handle, Parent, table);
    elseif obj.ClassName == "Pants" or obj.ClassName == "Shirt" or obj.ClassName == "Humanoid" then
        local clone = obj:clone();
        clone.Parent=Parent
        -- Changed Property
        local prop_change = nil;
        prop_change = obj.Changed:Connect(function(property)
            local success, err = pcall(function()
                clone[property] = obj[property];
            end)
            if not success then
                prop_change:Disconnect();
            end
        end)
    end
end
local function clear_render(viewport, threads)
    for i, thread in pairs(threads) do
		Destructor(thread)
    end
    ViewPort:ClearAllChildren()
end

local function ESP_Load()
    clear_render(ViewPort, Threads);
	for i, p in pairs(game.Players:GetChildren()) do
	    if p.Character ~= Player.Character then
            RenderObj(p.Character, ViewPort, Threads);
        end
	end
	print(HT:JSONEncode(Threads))
end
ESP_Load();